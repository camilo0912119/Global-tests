# -*- coding: utf-8 -*-
"""Test SQL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IPfIsPrC3uN2-h6jHc5wyNReRkapQ-_X

SQL TEST

Number 1
"""

import pandas as pd

"""First, we need to read all the data sources and include the names since they are not present in the original files.\
In addition, we include a sample of the data for reviewing it briefly after processing.
"""

names=['department_id','department']
departments=pd.read_csv("departments.csv",names=names)
departments.head()

names=['job_id','job']
jobs=pd.read_csv("jobs.csv",names=names)
jobs.head()

names=['hired_employees_id','name','datetime','department_id','job_id']
hired_employees=pd.read_csv("hired_employees.csv",names=names)
hired_employees.head()

"""Create a 'year' column derived from the 'datetime' column to facilitate filtering information for the year 2021."""

hired_employees['year']=pd.DatetimeIndex(hired_employees['datetime']).year
hired_employees.head()

"""Before filtering the 'hired_employees' DataFrame, we review its shape to analyze the filtered results."""

hired_employees.shape

hired_employees=hired_employees[hired_employees['year']==2021]
hired_employees.shape

"""Afterward, we merge all the DataFrames to create a unified one that can be applied to both questions. We use the 'inner' method due to the data model being a transaction table and two dimensions. For this, we only need the rows that intersect in the join, so it is an inner join"""

merged_df = pd.merge(hired_employees, departments, left_on='department_id', right_on='department_id', how='inner')
merged_df = pd.merge(merged_df, jobs, left_on='job_id', right_on='job_id', how='inner')
merged_df.head()

"""Next is the creation of a column for the 2021 quarter"""

merged_df['datetime'] = pd.to_datetime(merged_df['datetime'])
merged_df['quarter'] = merged_df['datetime'].dt.to_period('Q')
merged_df.head()

"""The next step is to group the table by the 'quarter,' 'job,' and 'department' columns to obtain the number of employees that match within these categories"""

result_df = merged_df.groupby(['department', 'job', 'quarter']).size().reset_index(name='number_of_employees')
result_df.head()

"""Finally, we pivot the table to create columns for each quarter and rename all the columns to ensure correct naming for the intended purpose."""

result_pivot = result_df.pivot_table(index=['department', 'job'], columns='quarter', values='number_of_employees', fill_value=0)
result_pivot.reset_index(inplace=True)
result_pivot.index.name = None
result_pivot.columns.name = None
result_pivot = result_pivot.sort_values(by=['department', 'job'])
result_pivot.columns=['department','job','Q1','Q2','Q3','Q4']
result_pivot.head()

"""Number 2

First, we need to obtain a table that contains all the employees per department. With that, we can calculate the mean of this value.
"""

count_employees = merged_df.groupby('department')['hired_employees_id'].count()
print(count_employees)

mean_employees=count_employees.mean()
print(mean_employees)

"""After obtaining the mean, we need to create a list of departments that have a total number of employees more than the mean."""

departments_above_mean = merged_df.groupby('department').filter(lambda x: len(x) > mean_employees)['department'].unique()
print(departments_above_mean)

"""Filter the employee count by department to include only those departments whose total employee count is above the mean."""

count_employees_department = count_employees.loc[departments_above_mean]
print(count_employees_department)

"""Finally, obtain the final result by ordering it based on the count and joining it with the original department table to include the department ID"""

result_df = pd.merge(departments, count_employees_department, left_on='department', right_index=True, how='inner')
result_df.columns=['id','department','hired']
result_df=result_df.sort_values(by=['hired'],ascending=False)
print(result_df)